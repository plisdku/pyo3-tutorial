# Learning PyO3

November 26, 2025

## Learned last time

 - Let's use `uv init`, `uv add`, `uv run`
   - the point of `uv run` is it always uses `.venv`
 - `uv run maturin init` will set up the rust + python project, but only if one hasn't been set up before
 - `uv run maturin develop` compiles the rust stuff and installs it in site-packages
 - you have to write your own `.pyi` files for now to get docstrings in your IDE for the rusty stuff.
   - the `__doc__` attribute is set by PyO3 or maturin or something, for the little that's worth
 - in Rust, Python objects are wrapped in smart pointers like `Py<T>`

# Rust modules

I never really got this figured out. I'm not a fan of this `lib.rs` thing, it's terribly confusing trying to open the right file in an IDE. Anyway, let's review the options.

It seems that there may be no nice way to attach `#[pymodule]` to multiple files at once.

Anyway, I'm trying some other of their examples and I note that with pyo3 0.27.1, I can't actually run their example:

```

#[pymodule]
fn my_extension(py: Python<'_>, m: &PyModule) -> PyResult<()> {
    ...
}
```

because of something something trait bounds. But some chaps on StackOverflow dug in and found that you need to do this:

```
#[pymodule]
fn my_extension(py: Python<'_>, m: Bound<'_, PyModule>) -> PyResult<()> {
    ...
}
```

I got into this situation because I wanted to do a nicer factoring of my rust code so I don't have to implement everything directly in `src/lib.rs`. Thing is, the recent documentation doesn't even offer this way of making extensions anymore, they really only say to put `#[pymodule]` on a `mod` declaration.

Well, I don't need to rock the boat. Circle back later I guess.

# Github issues

These seem a bit different than Gitlab. I make an issue, _manually_ make a branch to work on the issue, and when I'm ready to merge something I can make a PR.

```
% gh issue create

Creating issue in plisdku/pyo3-tutorial

? Title (required) implement a sorting algorithm in rust
? Body <Received>
? What's next? Submit
https://github.com/plisdku/pyo3-tutorial/issues/1
```

Okee dokee. Then I made a branch, `issue/1`.


# How arguments get into Rust modules

Something converts python arguments into Rust types. How does this work?

# Returning `PyResult`

According to the docs, `PyResult` is an alias for `Result<T, PyErr>` and can be used [if a PyO3 API could result in a Python exception being raised](https://pyo3.github.io/pyo3/v0.27.0/function/error-handling.html).

To raise an exception from a `#[pyfunction]`, the return type of the function should be `PyResult<T>`. Then when the function returns any `Err` you'll get a Python exception. In fact you may use any `Result<T,E>` as long as `E` has a `From` conversion for `PyErr`.

It seems there are subtypes in `pyo3::exceptions`, e.g.
 - `PyValueError` becomes a Python `ValueError`

# Type conversions

Arguments _to_ my Rust API need to implement `FromPyObject`, and arguments _from_ my Rust API need to implement `IntoPyObject`. Some Python types can be converted to Rust types; also, Python types can be wrapped in objects so Rust can handle them without conversion.

 There is a [conversion table](https://pyo3.github.io/pyo3/v0.27.0/conversions/tables.html). Key points:
 - `object` must be wrapped by `PyAny`
 - `str` can be converted to `String`, `&str`, `char`, `Path`, etc. or wrapped by `PyString`
 - `int` can be converted to basically any integer type
 - `float` can be converted to `f32` and `f64` and others
 - `complex` can be converted to `num_complex::Complex`
 - `list[T]` can be converted to `Vec<T>`
 - `dict[K, V]` can be converted to `HashMap<K, V>` and others
 - `tuple[T,U]` can be converted to `(T,U)` or `Vec<T>`
 - `set[T]` can be converted to `HashSet<T>` and others

A more restricted set of Rust types can be automatically converted back to Python types; this includes standard library types.

